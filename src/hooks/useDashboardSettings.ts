import { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase'; // Ensure this path is correct for your supabase client
import { useAuth } from './useAuth'; // Your custom hook for authentication
import { UserDashboardSettings } from '../types'; // Your TypeScript type for settings

export const useDashboardSettings = () => {
  const { user } = useAuth(); // Provides the authenticated user object
  const [settings, setSettings] = useState<UserDashboardSettings | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchAndOrCreateSettings = async () => {
      // Ensure user is authenticated and user.id is available
      if (!user?.id) {
        setLoading(false);
        setSettings(null); // Clear settings if no user
        setError(null); // Clear any previous error
        return;
      }

      try {
        setLoading(true);
        setError(null);

        // 1. Attempt to fetch existing settings using .maybeSingle()
        const { data: existingSettings, error: fetchError } = await supabase
          .from('user_dashboard_settings')
          .select('*')
          .eq('user_id', user.id) // user.id comes from auth.users
          .maybeSingle(); // Use .maybeSingle() to allow zero rows without error

        if (fetchError) {
          // This will catch actual network errors or RLS issues,
          // but not "no rows found" which .maybeSingle() handles.
          console.error(
            'Error fetching dashboard settings (initial fetch):',
            fetchError
          );
          throw fetchError;
        }

        if (existingSettings) {
          // Settings found, update the state
          setSettings(existingSettings as UserDashboardSettings);
        } else {
          // No settings found, proceed to create default settings
          console.log(
            `No settings found for user ${user.id}, creating default settings.`
          );
          const { data: newSettings, error: createError } = await supabase
            .from('user_dashboard_settings')
            .insert({
              user_id: user.id, // This is the foreign key linking to auth.users.id
              // Default values for your settings:
              layout: [], // Ensure this matches your 'Json' type for layout
              theme: 'light',
              widgets_config: {}, // Ensure this matches your 'Json' type
              notifications_enabled: true,
              // 'id', 'created_at', 'updated_at' are usually auto-generated by Supabase/PostgreSQL
            })
            .select() // Select the newly inserted row
            .single(); // .single() is appropriate here, as an insert should return exactly one row

          if (createError) {
            console.error(
              'Error creating default dashboard settings:',
              createError
            );
            throw createError;
          }
          setSettings(newSettings as UserDashboardSettings);
        }
      } catch (err) {
        // Catch any errors from fetching or creating settings
        console.error('Error in fetchAndOrCreateSettings:', err);
        setError(
          err instanceof Error
            ? err.message
            : 'Failed to load or create dashboard settings'
        );
        setSettings(null); // Clear settings on error
      } finally {
        setLoading(false);
      }
    };

    fetchAndOrCreateSettings();
  }, [user]); // Re-run effect when the user object changes

  const updateSettings = async (updates: Partial<UserDashboardSettings>) => {
    // Ensure user is authenticated and there are existing settings to update (identified by settings.id)
    if (!user?.id || !settings?.id) {
      const errMsg = 'User not authenticated or no settings to update.';
      setError(errMsg);
      return { success: false, error: new Error(errMsg) };
    }

    try {
      setLoading(true);
      setError(null);

      const { data: updatedSettingsData, error: updateError } = await supabase
        .from('user_dashboard_settings')
        .update(updates)
        .eq('id', settings.id) // Update by the primary key 'id' of the user_dashboard_settings table
        .select()
        .single(); // Expect one row back after update

      if (updateError) {
        throw updateError;
      }

      setSettings(updatedSettingsData as UserDashboardSettings);
      return { success: true, data: updatedSettingsData };
    } catch (err) {
      console.error('Error updating dashboard settings:', err);
      const errorMsg =
        err instanceof Error ? err.message : 'Failed to update settings';
      setError(errorMsg);
      return {
        success: false,
        error: err instanceof Error ? err : new Error(errorMsg),
      };
    } finally {
      setLoading(false);
    }
  };

  return {
    settings,
    loading,
    error,
    updateSettings,
  };
};
